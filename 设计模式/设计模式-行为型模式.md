行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。

关于结构型模式的相关[demo](https://git.oschina.net/gtwlover/design-pattern/tree/master/behavioral)已在码云上传。

通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

行为型模式分为类行为型模式和对象行为型模式两种：

a.类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。

b.对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。

1. 模板方法模式

   ![模板方法模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 定义一些算法框架,如templateMethod(),而一些步骤延续到子类中,如:doSomething()
     * 子类不改变算法结构,可重新定义算法的特定步骤
     *
     * 优点:
     *      1.封装不变部分,扩展可变部分
     *      2.提取公共代码便于维护
     *      3.行为由父类控制,子类实现
     * 使用场景:
     *      1.多个子类有公共的方法,并且基本逻辑相同
     *      2.重要、复杂的算法可以把核心算法定为模板方法,周边相关细节由子类具体实现
     * 最佳实践:
     *      许多开源框架,提供一个抽象类,然后写了一堆子类,如果需要扩展功能,可以继承这个抽象类,覆写protected方法,
     *      最后调用一个类似execute()的方法
     */
   ```

2. 中介者模式

   ![中介者模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 每一个同事角色都知道中介者角色,而且与其他同事的通信,一定要通过中介者角色
     * 同事类行为分为两种:1.自发行为,处理自己的行为,与其他同事类和中介没有依赖;2.必须依赖中介才能完成
     * 同事类必须依赖中介者,所以使用构造函数注入
     *
     * 中介用于各个同事角色之间的通信,所以必须依赖各个同事角色(一般注入同事的实现类)
     * 同事类虽然有抽象,但没有每个同事类必须完成的业务,如果每个同事类都有相同的方法,如:execute(),可以注入抽象类
     * 中介可以只有部分同事类,所以用set()方法注入
     */
     
   /**
     * 优点:
     *      减少类之间的依赖,同事类只依赖中介,减少依赖,也降低类之间的耦合
     * 缺点:
     *      中介者会膨胀的很大,而且逻辑复杂
     * 使用场景:
     *      多个对象之间紧密耦合:在类图中出现蜘蛛网结构(并不是说一个类依赖多个类的情况),有利于把蜘蛛网梳理成星型结构,使混乱关系变的清晰
     * 实际应用:
     *      1.调度系统
     *      2.MVC框架,C就是一个中介者
     *      3.中介服务
     */
   ```

3. 命令模式

   ![命令模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 指定需要执行的命令,具体的命令需要指定执行者
     * 调用者接受命令,决定命令开始执行
     * 优点:
     *      1.类间解耦:调用者只需要调用command.execute()让命令去执行,不需要了解到底哪个接受者执行
     *      2.可扩展性:Command子类非常容易扩展,调用者Invoker和高层不产生严重耦合
     *      3.可以结合其他模式:结合责任链模式,实现命令族解析任务;结合模板方法模式,可以减少Command子类;结合备忘录模式还原最后状态
     * 缺点:
     *      命令越多,Command的子类越多
     *
     */
   ```

4. 责任链模式

   ![责任链模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 责任链模式核心在"链"上,是由多个ConcreteHandler组成
     * 抽象Handler三个职责:
     *      1.设置下一个处理者;
     *      2.定义具体处理者必须实现的两个方法:设置自己能处理的等级和具体的处理任务逻辑
     *      3.定义唯一对外开放的方法,请求处理的方法handleMessage
     * 优点:
     *      将请求和处理进行分开,请求者不用知道是谁处理的,处理者不用知道请求的全貌(单一职责原则、迪米特法则)
     * 缺点:
     *      因为是链式结构,性能是最大问题,而且调试很不方便
     * 注意事项:
     *      要注意链的长度,最好设定一个阈值,setNext()不允许超过最大值
     */
   ```

5. 策略模式

   ![策略模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 策略接口定义每个算法策略必须有的方法和属性
     * 优点:
     *      1.算法可以自由切换
     *      2.扩展性好,增加新的策略非常方便
     * 缺点:
     *      1.策略类过多
     *      2.所有具体策略都需要对外暴露,违反迪米特法则(可以用工厂方法、享元模式、代理模式修正)
     * 使用场景:
     *      1.多个类只在算法行为上稍有不同的地方
     *      2.算法需要自由切换的场景
     *      3.屏蔽算法规则的场景:只需要知道名字,传递相关数字就可以获得结论
     *
     */
   ```

6. 迭代器模式

   ![迭代器模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 提供了遍历容器的方便性,容器只要管理增减元素就可以了,要遍历时交给迭代器进行
     * 迭代器类似数据库的游标,可以在容器内上下翻滚,遍历所有它需要查看的元素
     * 注意:
     *      如果是JAVA开发者,尽量不要自己写迭代器,基本java的集合类都实现了Iterator
     */
   ```

7. 观察者模式

   ![观察者模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 对象间存在一对多的依赖关系,使得每一个对象改变状态,所有依赖它的对象都会得到通知并自动更新
     * java.util提供观察者模式,对于被观察者,提供了Observable类,注入观察者后,调用notifyObservers(this);
     * 对于观察者,提供了Observer接口重写update接口
     * 优点:
     *      观察者和被观察者进行解耦
     * 缺点:
     *      观察者过多,会有效率问题,java自身的采用顺序执行
     * 使用场景:
     *      事件多级触发
     *      关联行为场景,需要注意关联关系是可拆分,不是"组合"关系
     * 注意事项:
     *      观察模式最多出现一个对象既是观察者又是被观察者
     *      与责任链的区别是,观察者广播链在传播的过程中消息是随时更改的,责任链在过程中基本上保持消息不可变
     */
   ```

8. 备忘录模式

   ![备忘录模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 使用场景:
     *      需要保存和恢复数据的场景
     *      提供回滚操作,如:ctrl+z
     *      实现多份备忘录,只需要在备忘录管理员里改为容纳多个备忘录的Map即可
     * 注意事项:
     *      生命周期:备忘录创建处理就要在最近的代码中使用,要主动管理其生命周期,建立就要使用,不用就立刻删除其引用
     *      性能:不要在频繁建立备份的场景中使用备忘录,1是控制不了备忘录建立对象的数量,2是大对象的建立要消耗资源,性能方面需要考虑
     *      通过clone方式,自我实现备忘录功能的,使用在比较简单的场景中,尽量不要与其他对象产生严重的耦合
     */
   ```

9. 访问者模式

   ![访问者模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 在不改变结构体的情况下,为结构体中每个元素定义新的操作
     * 抽象元素:声明接受哪一类访问者,是通过accept方法中的参数来定义的；具体元素的accept方法,通常都是visitor.visit(this)
     * 抽象访问者:声明访问者可以访问哪些元素；具体访问者定义访问到一个类后该干什么
     * 优点:
     *      1.单一职责原则:元素自身负责数据的加载,visitor负责新操作,职责分明
     *      2.良好的扩展性:继续增加对数据的操作非常快捷,直接在visitor中增加一个方法
     * 缺点:
     *      1.访问者关注了元素类的内部细节,违反迪米特法则
     *      2.具体元素的增删改(如:再扩增一个具体element),visitor就需要修改,增加对此元素的访问操作
     *      3.访问者依赖具体的元素,破坏了依赖倒置原则,扩展困难
     * 使用场景:
     *      1.一个对象结构包含很多类对象,想对这些对象实施一些依赖于其他类的操作,也就是说迭代器模式已经不能胜任的场景(业务要求遍历多个不同的对象)
     *      2.需要对一个对象结构中的对象进行很多不同且不相关的操作,想避免操作污染这些对象的类
     *      3.数据统计和报表的批处理,eg:统计1.5*elements1 和 1.7*elements2的情况
     *      多分派:
     *      public class RoleImp implement IRole{
     *          public void accept(AbstractActor actor){
     *              actor.act(this);
     *          }
     *          public void doSomething(){
     *              //做自己的事
     *          }
     *      }
     *      public class RealActor extends AbstractActor{
     *          public void act(RoleImpl role){
     *              //该角色下要做的
     *          }
     *      }
     *      4.方法中进行多次instanceof来进行判断,根据多分派变种:
     *      public void doSomething(IRole role){
     *         // if(role instanceof realRole){
     *                  //做1操作
     *         // }else{
     *                  //做2操作
     *         // }
     *          role.doSomething();
     *      }
     */
   ```

10. 状态模式

    ![状态模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.jpg)

    ```
    /**
      * 当一个对象的行为取决于一个或多个动态变化的属性,在与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化
      * 抽象状态角色中声明一个环境角色,并提供所有与状态有关的行为,由各个实现类实现
      * 具体状态有两个职责:处理本状态必须完成的任务,决定是否过度到其他状态
      * 环境角色有两个不成文规定:1.定义状态(状态为静态常量);2.行为委托,具有状态抽象角色定义的所有行为,具体执行使用委托
      * 优点:
      *      避免过多的if...else,减少程序复杂性
      * 缺点:
      *      状态多的话,子类会很多
      * 使用场景:
      *      1.行为随状态改变而改变的场景,如权限设计,不同人状态不同即使执行相同操作行为结果也不同
      *      2.条件判断语句的替代者,通过扩展子类实现了条件的判断处理
      * 注意事项:
      *      在行为受状态约束的情况下使用状态模式,对象状态最好不超过5个
      */
    ```

    ​