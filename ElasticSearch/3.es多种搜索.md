[TOC]

## Query String Search

```json
# 搜索全部内容
GET /ecommerce/product/_search


{
    # 耗费的毫秒数
    "took": 2, 
    # 是否超时
    "timed_out": false, 
    # 扫描分配
    "_shards": {
        "total": 5, 
        "successful": 5, 
        "failed": 0
    }, 
    "hits": {
        # 扫描总结果数
        "total": 3, 
        # 最高得分
        "max_score": 1, 
        "hits": [
            {
                "_index": "ecommerce", 
                "_type": "product", 
                "_id": "2", 
        		# 该条记录得分
                "_score": 1, 
        		# 记录内容
                "_source": {
                    "name": "jiajieshi yagao", 
                    "desc": "youxiao fangzhu", 
                    "price": 25, 
                    "producer": "jiajieshi producer", 
                    "tags": [
                        "fangzhu"
                    ]
                }
            }, 
            ....
        ]
    }
}
```

Query String Search还支持传递请求参数`?q=-field:content`，`-`表示查询field不包含指定内容，默认为`+`。`GET /ecommerce/product/_search?q=-name:yaogao`查询名称中不包含yaogao的商品。

也可以不加field直接进行搜索，`GET /ecommerce/product/_search?q=yaogao`，这样将document的内容整体变为一个content（Text类型），然后对这个content进行分词，做匹配搜索

`_search`查询，默认情况下没有timeout。`GET /ecommerce/product/_search?timeout=10ms`开启timeout机制，每个shard只能在指定的timeout时间内把查询到的结果返回（查到多少返回多少），这样可以为时间敏感的搜索提供良好的支持。



## 基本查询：使用es内置查询条件查询

一个查询语句的典型结构：

```json
GET /_search
{
    "query": {
        # 针对具体字段的查询结构
        QUERY_TYPE_NAME: {
            FIELD_NAME: {
                ARGUMENT: VALUE,
                ARGUMENT: VALUE,...
            }
        }
    } 
}
```

###查询所有文档

```json
# match_all相当于不带条件的全查询
GET /lagou/_search
{
    "query": {
        "match_all": {}
    }
}
```

### match查询

```json
GET /lagou/job/_search
{
    "query": {
      	# 根据分词器进行分词查询
        "match": {
            "title": "python学习"
        }
    },
	# 指定返回的字段
	"_source": ["title", "url"],
	# stored_fields也可以指定返回的字段，但只可以指定stored为true的字段，否则也不会显示
	"stored_fields": ["title","company"],
	# 高亮显示
	"highlight": {
        # 指定高亮需要添加的标签
        "pre_tags": "<span class='keyWord'>",
        "post_tags": "</span>",
        # 指定高亮的字段
        "fields": {
            "title": {},
    		"content": {}
        }
  	},
	# 插叙结果排序
	"sort": [
        { "work_years_min": "desc" }
    ],
	# 分页查询
	"from": 0,
	"size": 10
}
```

如果对一个string field进行排序，结果往往不准确，因为分词后是多个单词，再排序就不是我们想要的结果。通常解决方案是，将一个string field建立两次索引，一个分词，用来进行搜索；一个不分词，用来进行排序

```json
PUT /website 
{
    "mappings":{
        "article":{
            "properties":{
                "title":{
                    "type":"text",
                    "fields":{
                        # 再建一次索引，不使用分词，用于排序
                        "raw":{
                            "type":"string",
                            "index":"not_analyzed"
                        }
                    },
                	# 使用正排索引
                    "fielddata":true
                },
                ...
            }
        }
    }
}

GET /website/article/_search
{
    "query":{
        "match_all":{

        }
    },
    "sort":[
        {	
            # 对string使用新的排序列
            "title.raw":{
                "order":"desc"
            }
        }
    ]
}
```

### term精确查找

```json
GET /lagou/job/_search
{
    "query": {
      	# 相当于全匹配查询，如果字段有分词，分词结果必须完全匹配指定内容才会返回
        # 此处如果content使用默认分词，content字段中Python不会被搜索出来
        # 因为在分词时Python被分为python，精确匹配时匹配不到
        "term": {
            "content": "Python"
        }
    }
}

GET /lagou/job/_search
{
    "query": {
        "terms": {
      		# 满足数组中的任意一个都会返回
            "title": ["工程师", "python", "java"]
        }
    }
}
```

### filter查询

查询同时，通过filter不影响打分的情况下筛选数据

```json
GET /test/test/_search
{
    "query": {
        "constant_score": {
            "filter": {
                # term 查询被用于精确值匹配
              	# 这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串
                "term": {
                    "tag": "full_text"
                }
            }
        }
    }
}

GET /forum/article/_search
{
    "query" : {
        "constant_score" : { 
            "filter" : {
                "term" : { 
                    # 如果type=text，直接用 "articleID" : "XHDK-A-1293-#fJ3"搜索不到结果
                    # 因为会进行分词，用"articleID":"xhdk"或"1293"可以搜索到结果,但"XHDK"不行；
                    
                    # 如果type=keyword,这时相当于执行sql的=，"articleID" : "xhdk"搜不到结果
                    # 必须为"articleID":"XHDK-A-1293-#fJ3"才能搜到结果；
                    
                    # type=text，新版es默认会设置两个field，一个是field本身，比如articleID
                    # 还有一个就是field.keyword，默认不分词，会最多保留256个字符  
                    
                    # 对于不分词的term搜索，内容必须全匹配才可以搜到结果，
                    # articleID.keyword不分词，此处使用"XHDK-A-1293"搜不到结果
                    "articleID.keyword" : "XHDK-A-1293-#fJ3"
                }
            }
        }
    }
}
```

query查询：会计算doc对搜索条件的relevance score，还会根据这个score去排序
filter查询：只是简单过滤出想要的数据，不计算relevance score，也不排序

一个search请求中，可能会发出多个filter条件，会为每个filter条件在倒排索引中搜索到的结果，构建一个bitset，[0, 0, 0, 1, 0, 1]。**遍历每个filter条件对应的bitset，会先从最稀疏的开始遍历**，就可以先过滤掉尽可能多的数据。

filter比query的好处就在于会caching，但实际上缓存的并不是一个filter返回的完整的document list数据结果。而是将filter对应的bitset缓存起来，这样下次就不用扫描倒排索引了，可以大幅提升性能。

如果document有新增或修改，那么cached bitset会被自动更新。以后只要是有相同的filter条件的，会直接使用这个过滤条件对应的cached bitset。

### 其他基本查询

```json
# 短语查询
GET /lagou/_search
{
   "query": {
     # 查询首先解析查询字符串来产生一个词条列表。然后会搜索所有的词条，
	 # 但只保留含有了所有搜索词条的文档，并且词条的位置要邻接。
     "match_phrase": {
       "title": { // title字段
         # 先进行分词，拆分为[python, 系统]，要求必须满足所有分词
         "query": "python系统", 
       	 # slop指定了分词之间允许的最大距离
         "slop": 6
       }
     }
   }
}

# 多字段匹配查询
GET /lagou/_search
{
   "query": {
     "multi_match": {
       "query": "python",
        # 在多个字段中查询关键字，title的权重为3
       "fields": ["title^3", "desc"]
     }
   }
}

# 通配符查询
GET /my_index/address/_search
{
    "query": {
        "wildcard": {
          	# ? 匹配任意字符， * 匹配 0 或多个字符
            "postcode": "W?F*HW" 
        }
    }
}

# 正则查询
GET /my_index/address/_search
{
    "query": {
        "regexp": {
            "postcode": "W[0-9].+" 
        }
    }
}

# 范围查询
GET /my_store/products/_search
{
    "query": {
        "range": {
            "price": {
                "gte": 20, 
                "lt": 40, 
                "boost": 2 # 权重
            }
        }
    }
}
```

###`null`值处理：

```json
# SELECT * FROM posts WHERE tags IS NOT NULL
GET /my_index/posts/_search
{
    "query" : {
    	"bool": {
         	"filter" : {
                "exists" : { 
                    "field" : "tags" 
                }
        	}
        } 
    }
}

# SELECT * FROM  posts WHERE tags IS NULL
GET /my_index/posts/_search
{
    "query" : {
    	"bool": {
         	"filter" : {
                "missing" : { 
                    "field" : "tags" 
                }
        	}
        } 
    }
}
```



## 批量查询

批量查询可以减少网络开销，在进行查询时，**如果一次性要查询多条数据的话，一定要考虑批量操作，尽可能减少网络开销，提高性能**。es提供了`mget` API 可以检索很多文档，要求有一个 `docs` 数组作为参数：

```json
GET /_mget
{
   "docs" : [
      {
         "_index" : "website",
         "_type" :  "blog",
         "_id" :    2
      },
      {
         "_index" : "website",
         "_type" :  "pageviews",
         "_id" :    1,
         # 如果想检索一个或者多个特定的字段，那么可以通过 _source 参数来指定这些字段的名字
         "_source": "views"
      }
   ]
}

# 如果想检索的数据都在相同的 _index 中（甚至相同的 _type 中），则可以在 URL 中指定默认的 /_index/_type 
GET /website/blog/_mget
{
   "docs" : [
      { "_id" : 2 },
      { 
        "_type" : "pageviews", 
        "_id" :   1 
      }
   ]
}

# 如果所有文档的 _index 和 _type 都是相同的，可以只传一个 ids 数组，而不是整个 docs 数组：
GET /website/blog/_mget
{
   "ids" : [ "2", "1" ]
}

# 对于返回结果，如果第二个文档未能找到并不妨碍第一个文档被检索到，每个文档都是单独检索和报告的。
```



## 组合查询

==倒排索引源于应用中需要根据属性值来查找记录，索引表中每一项包括一个属性值和具有该属性值的各记录的地址。由于不是由记录确定属性值，而是由属性值确定记录的位置，因而称为倒排索引。==

Elasticsearch 使用的查询语言（DSL） 拥有一套查询组件，可以在以下两种情况下使用：过滤情况（filtering context）和查询情况（query context）。

- 当使用于 *过滤情况* 时，查询被设置成一个“不评分”查询。回答也是非常的简单，yes 或者 no ，二者必居其一。

  为了明确和简单，用 "filter" 这个词表示不评分

- 当使用于 *查询情况* 时，查询就变成了一个“评分”的查询。也要去判断这个文档是否匹配，==同时它还需要判断这个文档的匹配程度如何==。

  一个评分查询计算每一个文档与此查询的 _相关程度_，同时将这个相关程度分配给表示相关性的字段 `_score`，并且按照相关性对匹配到的文档进行排序。这种相关性的概念是非常适合全文搜索的情况，因为全文搜索几乎没有完全 “正确” 的答案。

```json
GET /test/test/_search
{
    "query": {
      	# 用 bool 查询来实现组合多查询
      	# 每一个子查询都独自地计算文档的相关性得分。
      	# 一旦他们的得分被计算出来， bool 查询就将这些得分进行合并并且返回一个代表整个布尔操作的得分。
        "bool": {
          	# 文档必须匹配这些条件才能被包含进来
      		# 如果没有 must 语句，那么至少需要能够匹配其中的一条 should 语句。
      		# 如果存在至少一条 must 语句，则对 should 语句的匹配没有要求。
            "must": {
      			# 无论在任何字段上进行的是全文搜索还是精确查询，match 查询是可用的标准查询。
      			# 在一个全文字段上使用 match 查询，在执行查询前，它将用正确的分析器去分析查询字符串
      			# 如果在一个精确值的字段上使用它，如数字、日期、布尔或者一个not_analyzed 字符串字段，那么它将会精确匹配给定的值：
                "match": {
                    "title": "how to make millions"
                }
            }, 
		   # 必须不匹配
            "must_not": {
                "match": {
                    "tag": "spam"
                }
            }, 
		   # 如果满足这些语句中的任意语句，将增加 _score ，否则，无任何影响。
		   # 主要用于修正每个文档的相关性得分。
            "should": [
                {
                    "match": {
                        "tag": "starred"
                    }
                }
            ], 
		   # 必须匹配，但它不评分，以过滤模式来进行，是根据过滤标准来排除或包含文档。
            "filter": {
              	# 将 bool 查询包裹在 filter 语句中，我们可以在过滤标准中增加布尔逻辑
                "bool": {
                    "must": [
                        {
                            "range": {
                                "price": {
                                    "lte": 29.99
                                }
                            }
                        }
                    ], 
                    "must_not": [
                        {
                            "term": {
                                "category": "ebooks"
                            }
                        }
                    ]
                }
            }
        }
		# 尽管没有 bool 查询使用这么频繁，constant_score 查询也是查询工具。
		# 它将一个不变的常量评分应用于所有匹配的文档。它被经常用于只需要执行一个 filter 而没有其它查询
		"constant_score":   {
              "filter": {
                  "term": { "category": "ebooks" } 
              }
          }
    }
}

```



## Scroll查询

scroll查询主要用于==海量数据查询==，一批一批查，直到所有数据查询完成。scroll查询会在第一次搜索的时候，保存一个当时的视图快照，之后只会基于该旧的视图快照进行数据搜索。如果期间数据发生变化，用户是看不到数据变化的。

```json
# scroll参数指定搜索请求的时间窗口
GET /jobbole/article/_search?scroll=1m
{
    "query":{
        "match_all":{}
    },
    "sort":[
        "_doc"
    ],
    "size":5
}

# 查询返回结果中会有scroll_id,下次scroll查询必须将此id带上
GET /_search/scroll
{
    "scroll":"1m",
    # scroll_id 会保存该次查询时的上下文
    "scroll_id":"DnF1ZX..."
}
```

