结构型模式(Structural Pattern)描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。

关于结构型模式的相关[demo](https://git.oschina.net/gtwlover/design-pattern/tree/master/structural)已在码云上传。

结构型模式可以分为类结构型模式和对象结构型模式： 

a.类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。

b.对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。

c.根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。

1. 代理模式

   ![代理模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%9E%8B/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 优点:
     *      1.职责清晰:真实角色实现具体业务逻辑,不关心非本职工作
     *      2.能够协调调用者和被调用者，在一定程度上降低了系统的耦合度
     * 缺点:
     *      1.有些类型的代理模式可能会造成请求的处理速度变慢
     *      2.实现代理模式需要额外的工作，有些代理模式的实现非常复杂
     * 使用场景:
     *      SpringAop是一个典型的动态代理
     */

   Subject subject = new Proxy(new RealSubject());
   subject.request();
   ```

   动态代理：

   ​       每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler

   ​       当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的invoke方法来进行调用。

   ​       通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的invoke方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。

2. 装饰模式

   ![装饰模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%9E%8B/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 动态给对象添加一些职责,此模式比生成子类更灵活(自我想象子类继承父类,子类再继承子类,职责更多则一层一层继承下去)
     * 优点:
     *      1.装饰类Decorator和被装饰类ConcreteComponent可以独立发展,不会互相耦合(Decorator引用的是Component)
     *      2.装饰模式是继承模式的一个代替方案,Decorator不管装饰多少层,返回的都是Component
     *      3.可以动态的扩展一个实现类的功能
     * 缺点:
     *      多层装饰是比较复杂的,尤其是最里面装饰出了问题
     * 使用场景:
     *      需要扩展一个类的功能,可以动态添加撤销功能
     */
     
     Component component = new ConcreteComponent();
     //第一次装饰
     component = new ConcreteDecorator1(component);
     //第二次装饰
     component = new ConcreteDecorator2(component);
     component.operate();

   ```

3. 适配器模式

   ![适配器模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%9E%8B/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 将一个类的接口转换成客户期望的另一个接口
     * 优点:
     *      1.可以让两个没有关系的类一起运行
     *      2.提高了类的复用度:源角色还可以在原系统中正常使用,目标角色也可以充当新的演员
     *      3.灵活性好:不想要适配器删了就好了
     * 使用场景:
     *      修改已经投产中的接口、系统扩展,已有类不符合系统接口
     * 注意:
     *      项目一定要符合里氏替换原则和依赖倒置原则
     *      适配器模式最好在详细设计阶段不要考虑,它是为了解决正在服役中的项目
     */
     
   /**
     * Adapter继承Adaptee叫做类适配器
     * Adapter如果将Adaptee作为属性使用
     * private Adaptee adaptee;---->adaptee.doSomething();
     * 这种方式叫做对象适配器
     */
   ```

4. 组合模式

   ![组合模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%9E%8B/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 将对象组合成树形结构以表示"部分-整体"的层次结构,使得用户对单个对象和组合对象的使用具有一致性
     * 优点:
     *      1.高层模块调用简单:树结构中所有节点都是Component,高层模块不必关注是单个对象还是整个组合结构,简化高层模块代码
     *      2.节点增加自由,非常容易扩展,符合开闭原则
     * 缺点:
     *      叶子和树枝直接使用的是实现类,与依赖倒置原则冲突
     *      此问题解决办法是将组合用到的方法全部放到抽象类中变为透明模式,如:add()、remove()、getChildren()
     *      这样不管叶子还是树枝都有相同的结构,通过判断getChildren()的返回值是叶子还是树枝
     *      如果处理不当会在运行时出现问题,不推荐此种方式
     * 使用场景:
     *      部分-整体的关系,如:文件夹、树形菜单,从整体能独立出部分模块或功能的场景
     * 注意:
     *      只要是树形结构就要考虑组合模式,体现整体和部分关系的时候,而且关系比较深,都应考虑此模式
     */
   ```

5. 门面模式

   ![门面模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%9E%8B/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 一个子系统与其他内部系统通信都必须经过一个统一的对象,门面系统注重"统一的对象",除了这个接口不允许有任何访问子系统的行为发生
     * Facade该角色知道子系统的所有功能和责任,该角色没有实际的业务逻辑,只是一个委托类
     * 子系统并不知道门面的存在,对子系统而言,门面仅是一个客户端而已
     * 优点:
     *      1.减少系统的互相依赖
     *      2.提高灵活性,不管子系统如何变化,只要不影响到门面系统,任由变化
     *      3.提高安全性,访问子系统只能通过门面进行
     * 缺点:
     *      不符合开闭原则,对修改关闭
     * 使用场景:
     *      1.为一个复杂的模块或子系统提供一个供外界访问的接口
     *      2.要求子系统相对独立——外界只能进行黑箱操作
     * 注意事项:
     *      1.一个子系统可以有多个门面:门面过于庞大、提供不同的路径访问(如果已经委托给已存在的门面处理,继续调用该门面处理)
     *      2.门面不参加子系统内的业务逻辑
     */
   ```

6. 享元模式

   ![享元模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%9E%8B/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 享元模式是池技术的重要实现方式,有两个要求:细粒度的对象和共享对象
     * 对象分为两个部分:内部状态和外部状态
     * 内部状态:是对象可以共享出来的对象,并且不会随环境的改变而改变
     * 外部状态:是对象可以依赖的一个标记,是随环境的改变而改变的,不可共享的状态
     * 优点:
     *      大大减少应用程序创建对象,降低程序内存的占用
     * 缺点:
     *      提高了系统复杂度,要分离出内部状态和外部状态
     * 使用场景:
     *      1.系统中存在大量相似的对象
     *      2.细粒度的对象都具备较接近的外部状态,而且内部状态都与环境无关
     *      3.需要缓冲池的场景
     */
   ```

7. 桥接模式

   ![桥接模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%9E%8B/%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 将抽象和实现解耦,使得两者可以独立变化,抽象角色引用实现角色,抽象角色的部分实现是由实现角色完成的
     * 完全是为了解决继承的缺点而提出的,实现完全不受抽象的约束
     * 优点:
     *      1.优秀的扩充能力,使得抽象和实现可以沿着各自的维度来变化,在两个变化维度中任意扩展一个维度，都不需要修改原有系统
     *      2.实现细节对客户透明，可以对用户隐藏实现细节,它已经由抽象层通过聚合关系完成了封装
     * 使用场景:
     *      1.一个类存在两个独立变化的维度，且这两个维度都需要进行扩展
     *      2.对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统
     *      3.虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者
     * 注意事项:
     *      桥梁模式的意图还是对变化的封装,尽量把可能变化的因素封装到最小逻辑单元,发现类的继承有N层时,考虑使用此模式
     */
   ```

   ​

