创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。

关于创建型模式的相关[demo](https://git.oschina.net/gtwlover/design-pattern/tree/master/creational)已在码云上传。

为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。 

创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。

创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。

1. 单例模式

   ![单例模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%9E%8B/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 优点:
     *      1.只有一个实例,减少内存开支
     *      2.当一个对象产生需要比较多资源时,只生成一个实例,减少系统系能开销,避免对资源多重占用
     * 缺点:
     *      1.没有接口,不利于扩展
     *      2.不利于测试,单例没有完成是不能进行测试的,没有接口,也不能使用mock创建虚拟对象
     * 使用场景:
     *      1.生成唯一对象
     *      2.共享数据对象
     *      3.创建一个对象消耗资源过多
     *      4.需要定义大量静态常量和方法(如工具类)
     * 最佳实践:
     *      Spring中每个Bean默认是单例的,Spring容器可以管理这些Bean的生命周期
     */
   ```

2. 工厂模式

   ![工厂模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%9E%8B/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 优点:
     *      1.良好的封装性,代码结构清晰,只需要知道具体创建对象的类名就可以创建该对象
     *      2.扩展性非常优秀,在增加产品类的时候,只需要修改具体的工厂类或扩展一个工厂类
     *      3.屏蔽产品类,产品类如何变化调用者都不需要关心
     * 使用场景:
     *      1.在所有生成对象的地方都可以考虑使用,但需要谨慎考虑是否需要增加一个工厂类进行管理,增加代码复杂度
     *      2.需要灵活可扩展的框架时,万物皆产品类
     *
     * 产品类实现比较复杂,每个实现类的初始化方法都不相同,如果写在一个工厂方法中,势必导致方法巨大无比
     * 所以,这时不同产品使用不同的工厂类,多工厂
     */
   ```

3. 抽象工厂

   ![抽象工厂](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%9E%8B/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 产品A,产品B称为产品族
     * 有多少个产品族,抽象工厂类中就必须有多少个创建方法
     * 产品的1,2称为产品等级
     * 有多少个产品等级就必须有多少个实现工厂类
     */

   /**
     * 优点:
     *      1.封装性强,只要知道工厂类是谁就能创建出想要的对象,如:要1类产品,只需要Creator1就行
     *      2.产品族内的约束为非公开状态,如:产品A与产品B的生成比例
     *      3.产品等级扩展容易,增加3类产品,只需要增加Creator3与对应产品等级
     * 缺点:
     *      1.产品族的扩展困难,要增加产品C,抽象工厂需要改,具体工厂实现全部要修改
     * 使用场景:
     *      一个对象族都有相同约束(即产品等级相同)
     * 最佳实践:
     *      软件开发涉及不同操作系统(不同操作系统可以看做产品等级),通过抽象工厂屏蔽掉操作系统对应用的影响,
     *      由不同产品类去处理与操作系统的交互信息
     */
   ```

4. 原型模式

   ![原型模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 通过复制一个实例对象本身来创建一个新的实例,通过原型实例创建新的对象，就不再需要关心这个实例本身的类型
     * 注意clone事项:
     *      1.clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效
     *      2.clone方法只会拷贝对象中的基本的数据类型(包括String)。对于数组、容器对象、引用对象等都不会拷贝，还是指向原生对象的内部元素地址,这就是浅拷贝。
     *        如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。
     *      3.Java语言里深度克隆一个对象，常常可以先使对象实现Serializable接口
     * 最佳实践:
     *      一个对象的产生可以不由零起步,可以直接从一个已经具备雏形的对象clone,然后再修改成生成所需的对象
     */
   ```

5. 建造者模式

   ![建造者模式](http://gtw.oss-cn-shanghai.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%9E%8B/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg)

   ```
   /**
     * 建造者模式:将一个复杂对象的构建(在Builder中)和它的表示(在Director中)分离,同样的创建过程(获取的产品的内部都是统一用builder.buildProduct())
     * 可以创建不同的表示(具体不同的builder创建出的产品是不同的)
     * 优点:
     *      1.封装性:客户点不必知道产品内部的组成细节
     *      2.建造者的实现类独立,容易扩展
     *      3.由于具体的建造者是独立的,因此对建造者过程细化,不会对其他模块产生影响
     * 使用场景:
     *      1.相同的方法,不同的执行顺序,产生不同结构时
     *      2.产品类中调用顺序不同,产生的能效不同
     * 注意事项:
     *      建造者模式关注的是零件类型和装配工艺(顺序),这是与工厂模式最大不同
     */
   ```

   ​