## TCC 解决方案框架

目前市面上的TCC框架众多，比如下面这几种：

| 框架名称        | Github地址                                      | star数 |
| --------------- | ----------------------------------------------- | ------ |
| tcc-transaction | https://github.com/changmingxie/tcc-transaction | 5.5k   |
| Hmily           | https://github.com/dromara/hmily                | 3.9k   |
| ByteTCC         | https://github.com/liuyangming/ByteTCC          | 2.8k   |
| EasyTransaction | https://github.com/QNJR-GROUP/EasyTransaction   | 2.3k   |

## 实现过程

- 一个完整的业务活动由一个主业务服务与若干从业务服务组成
- 主业务服务负责发起并完成整个业务活动
- 从业务服务提供对应TCC型业务操作
- **业务活动管理器**控制业务活动的一致性，登记业务活动的操作，并在业务活动提交时确认所有的TCC型的confirm操作，在业务活动取消调用所有TCC型操作的cancel操作

## 注意事项

### 允许空回滚

事务协调器在调用TCC服务的一阶段Try操作时，可能会出现因为丢包而导致的网络超时，此时事务协调器会触发二阶段回滚，调用TCC服务的Cancel操作；

TCC服务在未收到Try请求的情况下收到Cancel请求，这种场景被称为空回滚；TCC服务在实现时应当允许空回滚的执行；

解决思路：TM在发起全局事务时生成全局事务记录，全局事务ID贯穿整个分布式事务调用链条。再额外增加一张分支事务记录表，其中有全局事务 ID 和分支事务 ID，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了。Cancel 接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。

### 防悬挂控制

事务协调器在调用TCC服务的一阶段Try操作时，可能会出现因网络拥堵而导致的超时，此时事务协调器会触发二阶段回滚，调用TCC服务的Cancel操作；在此之后，拥堵在网络上的一阶段Try数据包被TCC服务收到，出现了二阶段Cancel请求比一阶段Try请求先执行的情况；

用户在实现TCC服务时，应当允许空回滚，但是要拒绝执行空回滚之后到来的一阶段Try请求；

解决思路：如果二阶段执行完成，那一阶段就不能再继续执行。在执行一阶段事务时判断在该全局事务下，“分支事务记录”表中是否已经有二阶段事务记录，如果有则不执行Try。



|                                                              | A系统                                                        | B系统                                          |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------- |
| Try 空悬挂处理，防止cancel和commit先到情况（框架应该有此考虑） | 1. 完成所有业务检查（一致性）<br />2. 预留必须的业务资源<br />3. 调用rpc接口 | 1. 完成所有业务检查（一致性）<br />2. 预留资源 |
| Confirm                                                      | 1. 不做任务业务检查<br />2. 只使用Try阶段预留的业务资源<br />3. 真正执行业务 | 对预留资源，做相应处理                         |
| Cancel 空回流处理，防止未接收到try阶段内容，做空回滚（框架应该有此考虑） | 释放Try阶段预留的业务资源                                    | 释放预留资源                                   |

## 流程说明（结合tcc-transaction框架）

主流程发起 -> 

1. 创建主事务（status=TRYING，type=ROOT）-> 记录主流程的事务参与者（targetClass，confirm，cancel）-> 执行主流程中的try方法 -> 记录子流程的事务参与者（targetClass，confirm，cancel）-> 子流程try方法执行
2. 主流程try执行完毕后，主流程切面拦截环绕后续继续调用参与者的confirm方法进行进一步处理 -> 调用子流程的commit接口，进入子流程的拦截，更新子流程的参与者状态为confirming，后执行子流程真的commit流程
3. confirm / cancel 操作都是获取到当前事务的所有参与者，然后让所有参与者执行对应操作

事务流程发生异常失败，**事务协调器**会根据事务记录发起重试调用，所以try / confirm / cancel接口都需要保持幂等性

